>###排序三---基于非比较的排序
>1、计数排序
>计数排序基于桶排序，原理比较简单，比如要将一个公司的员工按年龄进行排序，可以事先准备好20~100岁的桶，粒度为1，遍历员工，将其按年龄放入对应的桶内。然后再遍历桶，遍历出来的结果即为按顺序排列的结果。
>2、基数排序
>同样基于桶排序，但是和计数排序不一样。计数排序的桶个数随着所排序的对象改变，且有时候不可估计。而桶排序是针对整数（十进制），只有0~9十个桶。思想是：先将所有数按照个位放入桶中，再依次遍历桶，倒出所有数，然后再按倒出后得到的数的顺序遍历，按十位放入桶中，重复上面的操作，直到最高位。最后一次倒出的数即为排好序的数。

```java
public class RadixSort{
	public int[] radixSort(int[] A, int radix){
    	//radix为A数组中最大数的最高位数
    	//特殊输入
        if(A == null || A.length <= 0) return A;
        int n = A.length;
        //创建一个二维数组，即为桶，用来存放所有元素，为什么需要二维数组，因为每一个桶内还会有很多元素，显然一维数组做不到
        int[][] number = new int[10][n];//每一个桶最多n个
        int p = 1; // 记录是否到达高位
        
        while(p <= radix){
        	//遍历数组，放入对应的桶中,每个桶是一个一维数组，换位数时，需要重置
            int count[] = new int[10];//记录每个桶中的元素个数
            for(int i = 0; i < n; i++){
            	//计算A[i]的p位数，看它是在哪个桶中
            	int value = A[i]/(10*(p-1)) % 10;
                number[value][count[value]] = A[i];
                count[value]++;
            }
            //结束完遍历A数组之后，需要将桶中的元素取出重新放入A中,需要一个指针，在A中移动
            int index = 0;
            for(int i = 0; i < 10; i++){
            	for(int j = 0; j < count[i]; j++){
                	A[index++] = number[i][j];
                }
            }
            //完成了一次按照位数的遍历
            p++;
            //全部完成到最高位之后，A即为排好序了
        }
        return A
    }
}
```
总的来说，把思路理清晰了，还是很简单的。

>####排序算法的复杂度及稳定性总结
|       | 时间复杂度 | 空间复杂度                             |
|-------|:---:|-----------|-------:|
| O(1)  |     | 冒泡排序、选择排序、插入排序、希尔排序、堆排序     |
| O(M)  |     | 计数排序、基数排序                            |
| O(N) | 计数排序、基数排序  | 快速排序(logN~N)、归并排序        |
| O(NlogN)  | 希尔排序、归并排序、堆排序、快速排序   |           |
| O(N^2) | 冒泡排序、选择排序、插入排序   |

>稳定的：冒泡排序、插入排序、归并排序、计数排序、基数排序、桶排序
不稳定的：选择排序，快速排序，希尔排序，堆排序







